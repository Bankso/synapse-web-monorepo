(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
	(global = global || self, factory(global.SRC = {}, global.React));
}(this, function (exports, React) { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var runtime_1 = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  Function("r", "regeneratorRuntime = r")(runtime);
	}
	});

	/** QueryBundleRequest constants */
	var BUNDLE_MASK_QUERY_RESULTS = 1;
	var BUNDLE_MASK_QUERY_COUNT = 2;
	var BUNDLE_MASK_QUERY_SELECT_COLUMNS = 4;
	var BUNDLE_MASK_QUERY_MAX_ROWS_PER_PAGE = 8;
	var BUNDLE_MASK_QUERY_COLUMN_MODELS = 16;
	var BUNDLE_MASK_QUERY_FACETS = 32;
	/** EntityBundle constants */

	var ENTITY_BUNDLE_MASK_ENTITY = 1;
	var ENTITY_BUNDLE_MASK_ANNOTATIONS = 2;
	var ENTITY_BUNDLE_MASK_PERMISSIONS = 4;
	var ENTITY_BUNDLE_MASK_ENTITY_PATH = 8;
	var ENTITY_BUNDLE_MASK_HAS_CHILDREN = 32;
	var ENTITY_BUNDLE_MASK_ACL = 64;
	var ENTITY_BUNDLE_MASK_FILE_HANDLES = 2048;
	var ENTITY_BUNDLE_MASK_TABLE_DATA = 4096;
	var ENTITY_BUNDLE_MASK_ROOT_WIKI_ID = 8192;
	var ENTITY_BUNDLE_MASK_BENEFACTOR_ACL = 16384;
	var ENTITY_BUNDLE_MASK_DOI = 32768;
	var ENTITY_BUNDLE_MASK_FILE_NAME = 65536;
	var ENTITY_BUNDLE_MASK_THREAD_COUNT = 131072;
	var ENTITY_BUNDLE_MASK_RESTRICTION_INFORMATION = 262144;
	/** Row Types  */

	var STUDY = 'study'; // for study icons

	var STUDY_ACTIVE = 'study active';
	var STUDY_COMPLETE = 'study complete';
	var DATASET = 'dataset';
	var AMP_PROJECT = 'AMP_Project';
	var AMP_CONSORTIUM = 'AMP_Consortium';
	var AMP_STUDY = 'AMP_Study';
	var FUNDER = 'funder';
	var PUBLICATION = 'publication';
	var TOOL = 'tool';
	var CSBC_PROJECT = 'CSBC_PROJECT';
	var CSBC_PUBLICATION = 'CSBC_PUBLICATION';
	var CSBC_STUDY = 'CSBC_STUDY';
	var CSBC_DATASET = 'CSBC_DATSET';
	var GENERIC_CARD = 'GENERIC_CARD';
	var COMPUTATIONAL = 'computational';
	var EXPERIMENTAL = 'experimental';
	var CLINICAL = 'clinical';
	var PROJECT = 'Project';
	var PAGE_SIZE = 25; // For User Profile Cards

	var SMALL_USER_CARD = 'SMALL USER CARD';
	var MEDIUM_USER_CARD = 'MEDIUM USER CARD';
	var LARGE_USER_CARD = 'LARGE USER CARD';
	var SEPERATOR = 'SEPERATOR';

	var SynapseConstants = /*#__PURE__*/Object.freeze({
		BUNDLE_MASK_QUERY_RESULTS: BUNDLE_MASK_QUERY_RESULTS,
		BUNDLE_MASK_QUERY_COUNT: BUNDLE_MASK_QUERY_COUNT,
		BUNDLE_MASK_QUERY_SELECT_COLUMNS: BUNDLE_MASK_QUERY_SELECT_COLUMNS,
		BUNDLE_MASK_QUERY_MAX_ROWS_PER_PAGE: BUNDLE_MASK_QUERY_MAX_ROWS_PER_PAGE,
		BUNDLE_MASK_QUERY_COLUMN_MODELS: BUNDLE_MASK_QUERY_COLUMN_MODELS,
		BUNDLE_MASK_QUERY_FACETS: BUNDLE_MASK_QUERY_FACETS,
		ENTITY_BUNDLE_MASK_ENTITY: ENTITY_BUNDLE_MASK_ENTITY,
		ENTITY_BUNDLE_MASK_ANNOTATIONS: ENTITY_BUNDLE_MASK_ANNOTATIONS,
		ENTITY_BUNDLE_MASK_PERMISSIONS: ENTITY_BUNDLE_MASK_PERMISSIONS,
		ENTITY_BUNDLE_MASK_ENTITY_PATH: ENTITY_BUNDLE_MASK_ENTITY_PATH,
		ENTITY_BUNDLE_MASK_HAS_CHILDREN: ENTITY_BUNDLE_MASK_HAS_CHILDREN,
		ENTITY_BUNDLE_MASK_ACL: ENTITY_BUNDLE_MASK_ACL,
		ENTITY_BUNDLE_MASK_FILE_HANDLES: ENTITY_BUNDLE_MASK_FILE_HANDLES,
		ENTITY_BUNDLE_MASK_TABLE_DATA: ENTITY_BUNDLE_MASK_TABLE_DATA,
		ENTITY_BUNDLE_MASK_ROOT_WIKI_ID: ENTITY_BUNDLE_MASK_ROOT_WIKI_ID,
		ENTITY_BUNDLE_MASK_BENEFACTOR_ACL: ENTITY_BUNDLE_MASK_BENEFACTOR_ACL,
		ENTITY_BUNDLE_MASK_DOI: ENTITY_BUNDLE_MASK_DOI,
		ENTITY_BUNDLE_MASK_FILE_NAME: ENTITY_BUNDLE_MASK_FILE_NAME,
		ENTITY_BUNDLE_MASK_THREAD_COUNT: ENTITY_BUNDLE_MASK_THREAD_COUNT,
		ENTITY_BUNDLE_MASK_RESTRICTION_INFORMATION: ENTITY_BUNDLE_MASK_RESTRICTION_INFORMATION,
		STUDY: STUDY,
		STUDY_ACTIVE: STUDY_ACTIVE,
		STUDY_COMPLETE: STUDY_COMPLETE,
		DATASET: DATASET,
		AMP_PROJECT: AMP_PROJECT,
		AMP_CONSORTIUM: AMP_CONSORTIUM,
		AMP_STUDY: AMP_STUDY,
		FUNDER: FUNDER,
		PUBLICATION: PUBLICATION,
		TOOL: TOOL,
		CSBC_PROJECT: CSBC_PROJECT,
		CSBC_PUBLICATION: CSBC_PUBLICATION,
		CSBC_STUDY: CSBC_STUDY,
		CSBC_DATASET: CSBC_DATASET,
		GENERIC_CARD: GENERIC_CARD,
		COMPUTATIONAL: COMPUTATIONAL,
		EXPERIMENTAL: EXPERIMENTAL,
		CLINICAL: CLINICAL,
		PROJECT: PROJECT,
		PAGE_SIZE: PAGE_SIZE,
		SMALL_USER_CARD: SMALL_USER_CARD,
		MEDIUM_USER_CARD: MEDIUM_USER_CARD,
		LARGE_USER_CARD: LARGE_USER_CARD,
		SEPERATOR: SEPERATOR
	});

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
	  }

	  if (enumerableOnly) keys = keys.filter(function (sym) {
	    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	  });
	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    if (i % 2) {
	      var source = arguments[i] != null ? arguments[i] : {};
	      ownKeys(source, true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));
	    } else {
	      ownKeys(source).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(arguments[i], key));
	      });
	    }
	  }

	  return target;
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};

	  var target = _objectWithoutPropertiesLoose(source, excluded);

	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  }
	}

	function _iterableToArray(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	var sparkMd5 = createCommonjsModule(function (module, exports) {
	(function (factory) {
	    {
	        // Node/CommonJS
	        module.exports = factory();
	    }
	}(function (undefined$1) {

	    /*
	     * Fastest md5 implementation around (JKM md5).
	     * Credits: Joseph Myers
	     *
	     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
	     * @see http://jsperf.com/md5-shootout/7
	     */

	    /* this function is much faster,
	      so if possible we use it. Some IEs
	      are the only ones I know of that
	      need the idiotic second function,
	      generated by an if clause.  */
	    var add32 = function (a, b) {
	        return (a + b) & 0xFFFFFFFF;
	    },
	        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];


	    function cmn(q, a, b, x, s, t) {
	        a = add32(add32(a, q), add32(x, t));
	        return add32((a << s) | (a >>> (32 - s)), b);
	    }

	    function ff(a, b, c, d, x, s, t) {
	        return cmn((b & c) | ((~b) & d), a, b, x, s, t);
	    }

	    function gg(a, b, c, d, x, s, t) {
	        return cmn((b & d) | (c & (~d)), a, b, x, s, t);
	    }

	    function hh(a, b, c, d, x, s, t) {
	        return cmn(b ^ c ^ d, a, b, x, s, t);
	    }

	    function ii(a, b, c, d, x, s, t) {
	        return cmn(c ^ (b | (~d)), a, b, x, s, t);
	    }

	    function md5cycle(x, k) {
	        var a = x[0],
	            b = x[1],
	            c = x[2],
	            d = x[3];

	        a = ff(a, b, c, d, k[0], 7, -680876936);
	        d = ff(d, a, b, c, k[1], 12, -389564586);
	        c = ff(c, d, a, b, k[2], 17, 606105819);
	        b = ff(b, c, d, a, k[3], 22, -1044525330);
	        a = ff(a, b, c, d, k[4], 7, -176418897);
	        d = ff(d, a, b, c, k[5], 12, 1200080426);
	        c = ff(c, d, a, b, k[6], 17, -1473231341);
	        b = ff(b, c, d, a, k[7], 22, -45705983);
	        a = ff(a, b, c, d, k[8], 7, 1770035416);
	        d = ff(d, a, b, c, k[9], 12, -1958414417);
	        c = ff(c, d, a, b, k[10], 17, -42063);
	        b = ff(b, c, d, a, k[11], 22, -1990404162);
	        a = ff(a, b, c, d, k[12], 7, 1804603682);
	        d = ff(d, a, b, c, k[13], 12, -40341101);
	        c = ff(c, d, a, b, k[14], 17, -1502002290);
	        b = ff(b, c, d, a, k[15], 22, 1236535329);

	        a = gg(a, b, c, d, k[1], 5, -165796510);
	        d = gg(d, a, b, c, k[6], 9, -1069501632);
	        c = gg(c, d, a, b, k[11], 14, 643717713);
	        b = gg(b, c, d, a, k[0], 20, -373897302);
	        a = gg(a, b, c, d, k[5], 5, -701558691);
	        d = gg(d, a, b, c, k[10], 9, 38016083);
	        c = gg(c, d, a, b, k[15], 14, -660478335);
	        b = gg(b, c, d, a, k[4], 20, -405537848);
	        a = gg(a, b, c, d, k[9], 5, 568446438);
	        d = gg(d, a, b, c, k[14], 9, -1019803690);
	        c = gg(c, d, a, b, k[3], 14, -187363961);
	        b = gg(b, c, d, a, k[8], 20, 1163531501);
	        a = gg(a, b, c, d, k[13], 5, -1444681467);
	        d = gg(d, a, b, c, k[2], 9, -51403784);
	        c = gg(c, d, a, b, k[7], 14, 1735328473);
	        b = gg(b, c, d, a, k[12], 20, -1926607734);

	        a = hh(a, b, c, d, k[5], 4, -378558);
	        d = hh(d, a, b, c, k[8], 11, -2022574463);
	        c = hh(c, d, a, b, k[11], 16, 1839030562);
	        b = hh(b, c, d, a, k[14], 23, -35309556);
	        a = hh(a, b, c, d, k[1], 4, -1530992060);
	        d = hh(d, a, b, c, k[4], 11, 1272893353);
	        c = hh(c, d, a, b, k[7], 16, -155497632);
	        b = hh(b, c, d, a, k[10], 23, -1094730640);
	        a = hh(a, b, c, d, k[13], 4, 681279174);
	        d = hh(d, a, b, c, k[0], 11, -358537222);
	        c = hh(c, d, a, b, k[3], 16, -722521979);
	        b = hh(b, c, d, a, k[6], 23, 76029189);
	        a = hh(a, b, c, d, k[9], 4, -640364487);
	        d = hh(d, a, b, c, k[12], 11, -421815835);
	        c = hh(c, d, a, b, k[15], 16, 530742520);
	        b = hh(b, c, d, a, k[2], 23, -995338651);

	        a = ii(a, b, c, d, k[0], 6, -198630844);
	        d = ii(d, a, b, c, k[7], 10, 1126891415);
	        c = ii(c, d, a, b, k[14], 15, -1416354905);
	        b = ii(b, c, d, a, k[5], 21, -57434055);
	        a = ii(a, b, c, d, k[12], 6, 1700485571);
	        d = ii(d, a, b, c, k[3], 10, -1894986606);
	        c = ii(c, d, a, b, k[10], 15, -1051523);
	        b = ii(b, c, d, a, k[1], 21, -2054922799);
	        a = ii(a, b, c, d, k[8], 6, 1873313359);
	        d = ii(d, a, b, c, k[15], 10, -30611744);
	        c = ii(c, d, a, b, k[6], 15, -1560198380);
	        b = ii(b, c, d, a, k[13], 21, 1309151649);
	        a = ii(a, b, c, d, k[4], 6, -145523070);
	        d = ii(d, a, b, c, k[11], 10, -1120210379);
	        c = ii(c, d, a, b, k[2], 15, 718787259);
	        b = ii(b, c, d, a, k[9], 21, -343485551);

	        x[0] = add32(a, x[0]);
	        x[1] = add32(b, x[1]);
	        x[2] = add32(c, x[2]);
	        x[3] = add32(d, x[3]);
	    }

	    function md5blk(s) {
	        var md5blks = [],
	            i; /* Andy King said do it this way. */

	        for (i = 0; i < 64; i += 4) {
	            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
	        }
	        return md5blks;
	    }

	    function md5blk_array(a) {
	        var md5blks = [],
	            i; /* Andy King said do it this way. */

	        for (i = 0; i < 64; i += 4) {
	            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
	        }
	        return md5blks;
	    }

	    function md51(s) {
	        var n = s.length,
	            state = [1732584193, -271733879, -1732584194, 271733878],
	            i,
	            length,
	            tail,
	            tmp,
	            lo,
	            hi;

	        for (i = 64; i <= n; i += 64) {
	            md5cycle(state, md5blk(s.substring(i - 64, i)));
	        }
	        s = s.substring(i - 64);
	        length = s.length;
	        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
	        }
	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
	        if (i > 55) {
	            md5cycle(state, tail);
	            for (i = 0; i < 16; i += 1) {
	                tail[i] = 0;
	            }
	        }

	        // Beware that the final length might not fit in 32 bits so we take care of that
	        tmp = n * 8;
	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
	        lo = parseInt(tmp[2], 16);
	        hi = parseInt(tmp[1], 16) || 0;

	        tail[14] = lo;
	        tail[15] = hi;

	        md5cycle(state, tail);
	        return state;
	    }

	    function md51_array(a) {
	        var n = a.length,
	            state = [1732584193, -271733879, -1732584194, 271733878],
	            i,
	            length,
	            tail,
	            tmp,
	            lo,
	            hi;

	        for (i = 64; i <= n; i += 64) {
	            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
	        }

	        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
	        // containing the last element of the parent array if the sub array specified starts
	        // beyond the length of the parent array - weird.
	        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
	        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

	        length = a.length;
	        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= a[i] << ((i % 4) << 3);
	        }

	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
	        if (i > 55) {
	            md5cycle(state, tail);
	            for (i = 0; i < 16; i += 1) {
	                tail[i] = 0;
	            }
	        }

	        // Beware that the final length might not fit in 32 bits so we take care of that
	        tmp = n * 8;
	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
	        lo = parseInt(tmp[2], 16);
	        hi = parseInt(tmp[1], 16) || 0;

	        tail[14] = lo;
	        tail[15] = hi;

	        md5cycle(state, tail);

	        return state;
	    }

	    function rhex(n) {
	        var s = '',
	            j;
	        for (j = 0; j < 4; j += 1) {
	            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
	        }
	        return s;
	    }

	    function hex(x) {
	        var i;
	        for (i = 0; i < x.length; i += 1) {
	            x[i] = rhex(x[i]);
	        }
	        return x.join('');
	    }

	    // In some cases the fast add32 function cannot be used..
	    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
	        add32 = function (x, y) {
	            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
	                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	            return (msw << 16) | (lsw & 0xFFFF);
	        };
	    }

	    // ---------------------------------------------------

	    /**
	     * ArrayBuffer slice polyfill.
	     *
	     * @see https://github.com/ttaubert/node-arraybuffer-slice
	     */

	    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
	        (function () {
	            function clamp(val, length) {
	                val = (val | 0) || 0;

	                if (val < 0) {
	                    return Math.max(val + length, 0);
	                }

	                return Math.min(val, length);
	            }

	            ArrayBuffer.prototype.slice = function (from, to) {
	                var length = this.byteLength,
	                    begin = clamp(from, length),
	                    end = length,
	                    num,
	                    target,
	                    targetArray,
	                    sourceArray;

	                if (to !== undefined$1) {
	                    end = clamp(to, length);
	                }

	                if (begin > end) {
	                    return new ArrayBuffer(0);
	                }

	                num = end - begin;
	                target = new ArrayBuffer(num);
	                targetArray = new Uint8Array(target);

	                sourceArray = new Uint8Array(this, begin, num);
	                targetArray.set(sourceArray);

	                return target;
	            };
	        })();
	    }

	    // ---------------------------------------------------

	    /**
	     * Helpers.
	     */

	    function toUtf8(str) {
	        if (/[\u0080-\uFFFF]/.test(str)) {
	            str = unescape(encodeURIComponent(str));
	        }

	        return str;
	    }

	    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
	        var length = str.length,
	           buff = new ArrayBuffer(length),
	           arr = new Uint8Array(buff),
	           i;

	        for (i = 0; i < length; i += 1) {
	            arr[i] = str.charCodeAt(i);
	        }

	        return returnUInt8Array ? arr : buff;
	    }

	    function arrayBuffer2Utf8Str(buff) {
	        return String.fromCharCode.apply(null, new Uint8Array(buff));
	    }

	    function concatenateArrayBuffers(first, second, returnUInt8Array) {
	        var result = new Uint8Array(first.byteLength + second.byteLength);

	        result.set(new Uint8Array(first));
	        result.set(new Uint8Array(second), first.byteLength);

	        return returnUInt8Array ? result : result.buffer;
	    }

	    function hexToBinaryString(hex) {
	        var bytes = [],
	            length = hex.length,
	            x;

	        for (x = 0; x < length - 1; x += 2) {
	            bytes.push(parseInt(hex.substr(x, 2), 16));
	        }

	        return String.fromCharCode.apply(String, bytes);
	    }

	    // ---------------------------------------------------

	    /**
	     * SparkMD5 OOP implementation.
	     *
	     * Use this class to perform an incremental md5, otherwise use the
	     * static methods instead.
	     */

	    function SparkMD5() {
	        // call reset to init the instance
	        this.reset();
	    }

	    /**
	     * Appends a string.
	     * A conversion will be applied if an utf8 string is detected.
	     *
	     * @param {String} str The string to be appended
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.append = function (str) {
	        // Converts the string to utf8 bytes if necessary
	        // Then append as binary
	        this.appendBinary(toUtf8(str));

	        return this;
	    };

	    /**
	     * Appends a binary string.
	     *
	     * @param {String} contents The binary string to be appended
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.appendBinary = function (contents) {
	        this._buff += contents;
	        this._length += contents.length;

	        var length = this._buff.length,
	            i;

	        for (i = 64; i <= length; i += 64) {
	            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
	        }

	        this._buff = this._buff.substring(i - 64);

	        return this;
	    };

	    /**
	     * Finishes the incremental computation, reseting the internal state and
	     * returning the result.
	     *
	     * @param {Boolean} raw True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.prototype.end = function (raw) {
	        var buff = this._buff,
	            length = buff.length,
	            i,
	            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	            ret;

	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
	        }

	        this._finish(tail, length);
	        ret = hex(this._hash);

	        if (raw) {
	            ret = hexToBinaryString(ret);
	        }

	        this.reset();

	        return ret;
	    };

	    /**
	     * Resets the internal state of the computation.
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.reset = function () {
	        this._buff = '';
	        this._length = 0;
	        this._hash = [1732584193, -271733879, -1732584194, 271733878];

	        return this;
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @return {Object} The state
	     */
	    SparkMD5.prototype.getState = function () {
	        return {
	            buff: this._buff,
	            length: this._length,
	            hash: this._hash
	        };
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @param {Object} state The state
	     *
	     * @return {SparkMD5} The instance itself
	     */
	    SparkMD5.prototype.setState = function (state) {
	        this._buff = state.buff;
	        this._length = state.length;
	        this._hash = state.hash;

	        return this;
	    };

	    /**
	     * Releases memory used by the incremental buffer and other additional
	     * resources. If you plan to use the instance again, use reset instead.
	     */
	    SparkMD5.prototype.destroy = function () {
	        delete this._hash;
	        delete this._buff;
	        delete this._length;
	    };

	    /**
	     * Finish the final calculation based on the tail.
	     *
	     * @param {Array}  tail   The tail (will be modified)
	     * @param {Number} length The length of the remaining buffer
	     */
	    SparkMD5.prototype._finish = function (tail, length) {
	        var i = length,
	            tmp,
	            lo,
	            hi;

	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
	        if (i > 55) {
	            md5cycle(this._hash, tail);
	            for (i = 0; i < 16; i += 1) {
	                tail[i] = 0;
	            }
	        }

	        // Do the final computation based on the tail and length
	        // Beware that the final length may not fit in 32 bits so we take care of that
	        tmp = this._length * 8;
	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
	        lo = parseInt(tmp[2], 16);
	        hi = parseInt(tmp[1], 16) || 0;

	        tail[14] = lo;
	        tail[15] = hi;
	        md5cycle(this._hash, tail);
	    };

	    /**
	     * Performs the md5 hash on a string.
	     * A conversion will be applied if utf8 string is detected.
	     *
	     * @param {String}  str The string
	     * @param {Boolean} raw True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.hash = function (str, raw) {
	        // Converts the string to utf8 bytes if necessary
	        // Then compute it using the binary function
	        return SparkMD5.hashBinary(toUtf8(str), raw);
	    };

	    /**
	     * Performs the md5 hash on a binary string.
	     *
	     * @param {String}  content The binary string
	     * @param {Boolean} raw     True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.hashBinary = function (content, raw) {
	        var hash = md51(content),
	            ret = hex(hash);

	        return raw ? hexToBinaryString(ret) : ret;
	    };

	    // ---------------------------------------------------

	    /**
	     * SparkMD5 OOP implementation for array buffers.
	     *
	     * Use this class to perform an incremental md5 ONLY for array buffers.
	     */
	    SparkMD5.ArrayBuffer = function () {
	        // call reset to init the instance
	        this.reset();
	    };

	    /**
	     * Appends an array buffer.
	     *
	     * @param {ArrayBuffer} arr The array to be appended
	     *
	     * @return {SparkMD5.ArrayBuffer} The instance itself
	     */
	    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
	        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
	            length = buff.length,
	            i;

	        this._length += arr.byteLength;

	        for (i = 64; i <= length; i += 64) {
	            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
	        }

	        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

	        return this;
	    };

	    /**
	     * Finishes the incremental computation, reseting the internal state and
	     * returning the result.
	     *
	     * @param {Boolean} raw True to get the raw string, false to get the hex string
	     *
	     * @return {String} The result
	     */
	    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
	        var buff = this._buff,
	            length = buff.length,
	            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	            i,
	            ret;

	        for (i = 0; i < length; i += 1) {
	            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
	        }

	        this._finish(tail, length);
	        ret = hex(this._hash);

	        if (raw) {
	            ret = hexToBinaryString(ret);
	        }

	        this.reset();

	        return ret;
	    };

	    /**
	     * Resets the internal state of the computation.
	     *
	     * @return {SparkMD5.ArrayBuffer} The instance itself
	     */
	    SparkMD5.ArrayBuffer.prototype.reset = function () {
	        this._buff = new Uint8Array(0);
	        this._length = 0;
	        this._hash = [1732584193, -271733879, -1732584194, 271733878];

	        return this;
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @return {Object} The state
	     */
	    SparkMD5.ArrayBuffer.prototype.getState = function () {
	        var state = SparkMD5.prototype.getState.call(this);

	        // Convert buffer to a string
	        state.buff = arrayBuffer2Utf8Str(state.buff);

	        return state;
	    };

	    /**
	     * Gets the internal state of the computation.
	     *
	     * @param {Object} state The state
	     *
	     * @return {SparkMD5.ArrayBuffer} The instance itself
	     */
	    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
	        // Convert string to buffer
	        state.buff = utf8Str2ArrayBuffer(state.buff, true);

	        return SparkMD5.prototype.setState.call(this, state);
	    };

	    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

	    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

	    /**
	     * Performs the md5 hash on an array buffer.
	     *
	     * @param {ArrayBuffer} arr The array buffer
	     * @param {Boolean}     raw True to get the raw string, false to get the hex one
	     *
	     * @return {String} The result
	     */
	    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
	        var hash = md51_array(new Uint8Array(arr)),
	            ret = hex(hash);

	        return raw ? hexToBinaryString(ret) : ret;
	    };

	    return SparkMD5;
	}));
	});

	class BMF {
	  md5(file, md5Fn, progressFn) {
	    this.aborted = false;
	    this.progress = 0;
	    let currentChunk = 0;
	    const blobSlice =
	      File.prototype.slice ||
	      File.prototype.mozSlice ||
	      File.prototype.webkitSlice;
	    const chunkSize = 2097152;
	    const chunks = Math.ceil(file.size / chunkSize);
	    const spark = new sparkMd5.ArrayBuffer();
	    const reader = new FileReader();

	    loadNext();

	    reader.onloadend = e => {
	      spark.append(e.target.result); // Append array buffer
	      currentChunk++;
	      this.progress = currentChunk / chunks;

	      if (progressFn && typeof progressFn === 'function') {
	        progressFn(this.progress);
	      }

	      if (this.aborted) {
	        md5Fn('aborted');
	        return
	      }

	      if (currentChunk < chunks) {
	        loadNext();
	      } else {
	        md5Fn(null, spark.end());
	      }
	    };

	    /////////////////////////
	    function loadNext() {
	      const start = currentChunk * chunkSize;
	      const end = start + chunkSize >= file.size ? file.size : start + chunkSize;
	      reader.readAsArrayBuffer(blobSlice.call(file, start, end));
	    }
	  }

	  abort() {
	    this.aborted = true;
	  }
	}

	// TODO: Create JSON response types for all return types
	var IS_DEV_ENV = "production" === 'development' ? true : false;
	var DEV_ENV_SESSION_LOCAL_STORAGE_KEY = 'session-token-dev-mode-only';
	var DEFAULT_ENDPOINT = 'https://repo-prod.prod.sagebase.org/';
	var DEFAULT_SWC_ENDPOINT = 'https://www.synapse.org/'; // Max size file that we will allow the caller to read into memory (5MB)

	var MAX_JS_FILE_DOWNLOAD_SIZE = 5242880;
	var AUTH_PROVIDER = 'GOOGLE_OAUTH_2_0'; // This corresponds to the Synapse-managed S3 storage location:

	var SYNAPSE_STORAGE_LOCATION_ID = 1;
	var getRootURL = function getRootURL() {
	  var portString = window.location.port ? ":".concat(window.location.port) : '';
	  return "".concat(window.location.protocol, "//").concat(window.location.hostname).concat(portString, "/");
	};

	function delay(t) {
	  return new Promise(function (resolve) {
	    setTimeout(resolve.bind(null, {}), t);
	  });
	}

	function parseJSON(response) {
	  return response.text().then(function (text) {
	    var parsedJson = '';

	    try {
	      parsedJson = JSON.parse(text);
	    } catch (err) {
	      console.log('Caught exception with parsing json ', err);
	      parsedJson = text;
	    }

	    return parsedJson ? parsedJson : {};
	  }).catch( // this should never happen!
	  function (err) {
	    console.log('Caught exception loading response text ', err);
	    return {};
	  });
	}

	var fetchWithExponentialTimeout = function fetchWithExponentialTimeout(url, options, delayMs, retries) {
	  return fetch(url, options).then(function (resp) {
	    if (resp.status > 199 && resp.status < 300) {
	      if (resp.status === 204) {
	        // the response is empty, don't try to parse an empty response
	        return resp;
	      } // ok!


	      return parseJSON(resp);
	    }

	    if (resp.status === 429 || resp.status === 0) {
	      // TOO_MANY_REQUESTS_STATUS_CODE, or network connection is down.  Retry after a couple of seconds.
	      if (retries === 1) {
	        return Promise.reject({
	          reason: resp.statusText,
	          statusCode: resp.status
	        });
	      }

	      return delay(delayMs).then(function () {
	        return fetchWithExponentialTimeout(url, options, delayMs * 2, retries - 1);
	      });
	    } // error status that indicates no more retries


	    return resp.json().then(function (json) {
	      // on okay response return json, o.w. reject with json and
	      // send to catch block
	      var error = {
	        reason: json.reason,
	        status: resp.status
	      };
	      return resp.ok ? json : Promise.reject(error);
	    }).catch(function (error) {
	      // call failed above
	      if (error.reason && error.status) {
	        // successfull return from server but invalid call
	        // the call was recieved, but staus wasn't ok-- return the json response from above
	        // from the response directly
	        return Promise.reject({
	          reason: error.reason,
	          statusCode: error.status
	        });
	      }

	      return Promise.reject({
	        reason: resp.statusText,
	        statusCode: resp.status
	      });
	    });
	  }).catch(function (error) {
	    // this should never happen
	    return Promise.reject(error);
	  });
	};

	var doPost = function doPost(url, requestJsonObject, sessionToken, initCredentials, endpoint) {
	  var options = {
	    body: JSON.stringify(requestJsonObject),
	    headers: {
	      Accept: '*/*',
	      'Access-Control-Request-Headers': 'sessiontoken',
	      'Content-Type': 'application/json'
	    },
	    method: 'POST',
	    mode: 'cors',
	    credentials: initCredentials
	  };

	  if (initCredentials) {
	    options.credentials = initCredentials;
	  }

	  if (sessionToken) {
	    options.headers.sessionToken = sessionToken;
	  }

	  return fetchWithExponentialTimeout(endpoint + url, options, 1000, 5);
	};
	var doGet = function doGet(url, sessionToken, initCredentials, endpoint) {
	  var options = {
	    headers: {
	      Accept: '*/*',
	      'Access-Control-Request-Headers': 'sessiontoken'
	    },
	    method: 'GET',
	    mode: 'cors'
	  };

	  if (initCredentials) {
	    options.credentials = initCredentials;
	  }

	  if (sessionToken) {
	    options.headers.sessionToken = sessionToken;
	  }

	  return fetchWithExponentialTimeout(endpoint + url, options, 1000, 5);
	};
	var doPut = function doPut(url, requestJsonObject, sessionToken, initCredentials, endpoint) {
	  var options = {
	    body: JSON.stringify(requestJsonObject),
	    headers: {
	      Accept: '*/*',
	      'Access-Control-Request-Headers': 'sessiontoken',
	      'Content-Type': 'application/json'
	    },
	    method: 'PUT',
	    mode: 'cors'
	  };

	  if (initCredentials) {
	    options.credentials = initCredentials;
	  }

	  if (sessionToken) {
	    options.headers.sessionToken = sessionToken;
	  }

	  return fetchWithExponentialTimeout(endpoint + url, options, 1000, 5);
	};
	var putRefreshSessionToken = function putRefreshSessionToken(sessionToken) {
	  var endpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ENDPOINT;
	  return doPut('/auth/v1/session', {
	    sessionToken: sessionToken
	  }, undefined, undefined, endpoint);
	};
	var getVersion = function getVersion() {
	  var endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ENDPOINT;
	  return doGet('/repo/v1/version', undefined, undefined, endpoint);
	};
	var getQueryTableResultsFromJobId = function getQueryTableResultsFromJobId(entityId, jobId) {
	  var sessionToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  var updateParentState = arguments.length > 4 ? arguments[4] : undefined;
	  return doGet("/repo/v1/entity/".concat(entityId, "/table/query/async/get/").concat(jobId), sessionToken, undefined, endpoint).then(function (resp) {
	    // is this the job status?
	    if (resp.jobState && resp.jobState !== 'FAILED') {
	      updateParentState && updateParentState({
	        asyncJobStatus: resp
	      }); // still processing, wait for a second and try again

	      return delay(500).then(function () {
	        return getQueryTableResultsFromJobId(entityId, jobId, sessionToken, endpoint, updateParentState);
	      });
	    } // these must be the query results!


	    return resp;
	  }).catch(function (error) {
	    throw error;
	  });
	};
	/**
	 * http://docs.synapse.org/rest/POST/entity/id/table/query/nextPage/async/start.html
	 * @param {*} queryBundleRequest
	 * @param {*} sessionToken
	 * @param {*} endpoint
	 */

	var getQueryTableResults = function getQueryTableResults(queryBundleRequest) {
	  var sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	  var updateParentState = arguments.length > 2 ? arguments[2] : undefined;
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  return doPost("/repo/v1/entity/".concat(queryBundleRequest.entityId, "/table/query/async/start"), queryBundleRequest, sessionToken, undefined, endpoint).then(function (resp) {
	    return getQueryTableResultsFromJobId(queryBundleRequest.entityId, resp.token, sessionToken, endpoint, updateParentState);
	  }).catch(function (error) {
	    throw error;
	  });
	};
	/**
	 *  Run and return results from queryBundleRequest, queryBundle request must be of the
	 *  form:
	 *     {
	 *        concreteType: String,
	 *        query: {
	 *           sql: String,
	 *           isConsistent: Boolean,
	 *           partMask: Number
	 *        }
	 *     }
	 * @param {*} queryBundleRequest
	 * @param {*} [sessionToken=undefined]
	 * @param {boolean} [onlyGetFacets=false] Specify if the query only needs facets and no
	 * data-- (internally this limits the row count to 1 on the request)
	 * @returns Full dataset from synapse table query
	 */

	var getFullQueryTableResults =
	/*#__PURE__*/
	function () {
	  var _ref = _asyncToGenerator(
	  /*#__PURE__*/
	  regeneratorRuntime.mark(function _callee3(queryBundleRequest) {
	    var sessionToken,
	        query,
	        rest,
	        data,
	        maxPageSize,
	        queryRequest,
	        _args3 = arguments;
	    return regeneratorRuntime.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            sessionToken = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : undefined;
	            // TODO: Find out why theres a bug causing the query limit
	            query = queryBundleRequest.query, rest = _objectWithoutProperties(queryBundleRequest, ["query"]);
	            data = {};
	            maxPageSize = 150;
	            queryRequest = _objectSpread2({}, rest, {
	              query: _objectSpread2({}, query, {
	                limit: maxPageSize
	              }) // Have to make two "sets" of calls for query, the first one tells us the maximum size per page of data
	              // we can get, the following uses that maximum and offsets to the appropriate location to get the data
	              // afterwards, the process repeats

	            });
	            _context3.next = 7;
	            return getQueryTableResults(queryRequest, sessionToken).then(
	            /*#__PURE__*/
	            function () {
	              var _ref2 = _asyncToGenerator(
	              /*#__PURE__*/
	              regeneratorRuntime.mark(function _callee2(initData) {
	                var queryCount, currentQueryCount, getData;
	                return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                  while (1) {
	                    switch (_context2.prev = _context2.next) {
	                      case 0:
	                        queryCount = initData.queryResult.queryResults.rows.length;
	                        currentQueryCount = queryCount;
	                        data = initData; // Get the subsequent data, note- although the function calls itself, it runs
	                        // iteratively due to the await

	                        getData =
	                        /*#__PURE__*/
	                        function () {
	                          var _ref3 = _asyncToGenerator(
	                          /*#__PURE__*/
	                          regeneratorRuntime.mark(function _callee() {
	                            var queryRequestWithMaxPageSize;
	                            return regeneratorRuntime.wrap(function _callee$(_context) {
	                              while (1) {
	                                switch (_context.prev = _context.next) {
	                                  case 0:
	                                    if (!(queryCount === maxPageSize)) {
	                                      _context.next = 7;
	                                      break;
	                                    }

	                                    maxPageSize = initData.maxRowsPerPage;
	                                    queryRequestWithMaxPageSize = _objectSpread2({}, rest, {
	                                      query: _objectSpread2({}, query, {
	                                        limit: maxPageSize,
	                                        offset: currentQueryCount
	                                      })
	                                    });
	                                    _context.next = 5;
	                                    return getQueryTableResults(queryRequestWithMaxPageSize, sessionToken).then(function (postData) {
	                                      queryCount += postData.queryResult.queryResults.rows.length;

	                                      if (queryCount > 0) {
	                                        var _data$queryResult$que;

	                                        currentQueryCount += queryCount;

	                                        (_data$queryResult$que = data.queryResult.queryResults.rows).push.apply(_data$queryResult$que, _toConsumableArray(postData.queryResult.queryResults.rows));
	                                      }

	                                      return getData();
	                                    }).catch(function (err) {
	                                      console.log('Error on getting table results ', err);
	                                    });

	                                  case 5:
	                                    _context.next = 8;
	                                    break;

	                                  case 7:
	                                    return _context.abrupt("return", data);

	                                  case 8:
	                                  case "end":
	                                    return _context.stop();
	                                }
	                              }
	                            }, _callee);
	                          }));

	                          return function getData() {
	                            return _ref3.apply(this, arguments);
	                          };
	                        }();

	                        return _context2.abrupt("return", getData());

	                      case 5:
	                      case "end":
	                        return _context2.stop();
	                    }
	                  }
	                }, _callee2);
	              }));

	              return function (_x2) {
	                return _ref2.apply(this, arguments);
	              };
	            }());

	          case 7:
	            return _context3.abrupt("return", data);

	          case 8:
	          case "end":
	            return _context3.stop();
	        }
	      }
	    }, _callee3);
	  }));

	  return function getFullQueryTableResults(_x) {
	    return _ref.apply(this, arguments);
	  };
	}();
	/**
	 *  Log-in using the given username and password.  Will return a session token that must be used in
	 *  authenticated requests.
	 *  http://docs.synapse.org/rest/POST/login.html
	 */

	var login = function login(username, password) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doPost('/auth/v1/login', {
	    username: username,
	    password: password
	  }, undefined, undefined, endpoint);
	};
	/**
	 * Get redirect url
	 * https://docs.synapse.org/rest/POST/oauth2/authurl.html
	 * @param {*} provider
	 * @param {*} redirectUrl
	 * @param {*} endpoint
	 */

	var oAuthUrlRequest = function oAuthUrlRequest(provider, redirectUrl) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doPost('/auth/v1/oauth2/authurl', {
	    provider: provider,
	    redirectUrl: redirectUrl
	  }, undefined, undefined, endpoint);
	};
	/**
	 * Get session token from SSO
	 * https://docs.synapse.org/rest/POST/oauth2/session.html
	 * @param {*} provider
	 * @param {*} authenticationCode
	 * @param {*} redirectUrl
	 * @param {*} endpoint
	 */

	var oAuthSessionRequest = function oAuthSessionRequest(provider, authenticationCode, redirectUrl) {
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  return doPost('/auth/v1/oauth2/session', {
	    provider: provider,
	    authenticationCode: authenticationCode,
	    redirectUrl: redirectUrl
	  }, undefined, undefined, endpoint);
	};
	/**
	 * Create an entity (Project, Folder, File, Table, View)
	 * http://docs.synapse.org/rest/POST/entity.html
	 */

	var createEntity = function createEntity(entity, sessionToken) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doPost('/repo/v1/entity', entity, sessionToken, undefined, endpoint);
	};
	/**
	 * Create a project with the given name.
	 * http://docs.synapse.org/rest/POST/entity.html
	 */

	var createProject = function createProject(name, sessionToken) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return createEntity({
	    name: name,
	    concreteType: 'org.sagebionetworks.repo.model.Project'
	  }, sessionToken, endpoint);
	};
	/**
	 * Return this user's UserProfile
	 * http://docs.synapse.org/rest/GET/userProfile.html
	 */

	var getUserProfile = function getUserProfile(sessionToken) {
	  var endpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ENDPOINT;
	  return doGet('/repo/v1/userProfile', sessionToken, undefined, endpoint);
	};
	/**
	 * Return this user's UserProfile
	 * http://docs.synapse.org/rest/GET/userProfile.html
	 */

	var getUserProfileById = function getUserProfileById(sessionToken, ownerId) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doGet("/repo/v1/userProfile/".concat(ownerId), sessionToken, undefined, endpoint);
	};
	/**
	 * Return this user's profile bundle
	 * https://docs.synapse.org/rest/org/sagebionetworks/repo/model/UserBundle.html
	 */

	var getUserBundle = function getUserBundle(id, mask, sessionToken) {
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  return doGet("repo/v1/user/".concat(id, "/bundle?mask=").concat(mask), sessionToken, undefined, endpoint);
	};

	/**
	 * Return the User Profiles for the given list of user IDs
	 * http://docs.synapse.org/rest/POST/userProfile.html
	 */
	var getUserProfiles = function getUserProfiles(list) {
	  var sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doPost('/repo/v1/userProfile', {
	    list: list
	  }, sessionToken, undefined, endpoint);
	};
	/**
	 * Return the children (Files/Folders) of the given entity (Project or Folder).
	 * http://docs.synapse.org/rest/POST/entity/children.html
	 */

	var getEntityChildren = function getEntityChildren(request) {
	  var sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doPost('/repo/v1/entity/children', request, sessionToken, undefined, endpoint);
	};
	/**
	 * Retrieve an entityId for a given parent ID and entity name.
	 * https://docs.synapse.org/rest/POST/entity/child.html
	 */

	var lookupChildEntity = function lookupChildEntity(request) {
	  var sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doPost('/repo/v1/entity/child', request, sessionToken, undefined, endpoint);
	};
	/**
	 * Get a batch of pre-signed URLs and/or FileHandles for the given list of FileHandleAssociations.
	 * http://docs.synapse.org/rest/POST/fileHandle/batch.html
	 */

	var getFiles = function getFiles(request) {
	  var sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  return doPost('/file/v1/fileHandle/batch', request, sessionToken, undefined, endpoint);
	};
	/**
	 * Bundled access to Entity and related data components.
	 * An EntityBundle can be used to create, fetch, or update an Entity and associated
	 * objects with a single web service request.
	 * See SynapseClient.test.js for an example partsMask.
	 * https://docs.synapse.org/rest/org/sagebionetworks/repo/model/Entity.html
	 */

	var getEntity = function getEntity() {
	  var sessionToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	  var entityId = arguments.length > 1 ? arguments[1] : undefined;
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  var url = "/repo/v1/entity/".concat(entityId);
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	var updateEntity = function updateEntity(entity) {
	  var sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  var url = "/repo/v1/entity/".concat(entity.id);
	  return doPut(url, entity, sessionToken, undefined, endpoint);
	};
	/**
	 * Bundled access to Entity and related data components.
	 * An EntityBundle can be used to create, fetch, or update an Entity and
	 * associated objects with a single web service request.
	 * See SynapseClient.test.js for an example partsMask.
	 * http://docs.synapse.org/rest/GET/entity/id/version/versionNumber/bundle.html
	 */

	var getEntityBundleForVersion = function getEntityBundleForVersion(entityId, version, partsMask) {
	  var sessionToken = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
	  var endpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_ENDPOINT;
	  var url = "/repo/v1/entity/".concat(entityId);

	  if (version) {
	    url += "/version/ + ".concat(version);
	  }

	  url += "/bundle?mask= ".concat(partsMask);
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	/**
	 * Get Wiki page contents, call is of the form:
	 * http://docs.synapse.org/rest/GET/entity/ownerId/wiki.html
	 */

	var getEntityWiki = function getEntityWiki(sessionToken, ownerId, wikiId) {
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  var url = "/repo/v1/entity/".concat(ownerId, "/wiki/").concat(wikiId);
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	/**
	 * Returns synapse user favorites list given their session token
	 * http://docs.synapse.org/rest/GET/favorite.html
	 */

	var getUserFavorites = function getUserFavorites(sessionToken) {
	  var endpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ENDPOINT;
	  var url = 'repo/v1/favorite?offset=0&limit=200';
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	/**
	 *  http://docs.synapse.org/rest/GET/projects/type.html
	 *  @param {String} projectDetails Can be "MY_PROJECTS", "MY_CREATED_PROJECTS" or "MY_PARTICIPATED_PROJECTS"
	 */

	var getUserProjectList = function getUserProjectList(sessionToken, projectDetails) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  var url = "repo/v1/projects/".concat(projectDetails, "?offset=0&limit=200");
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	/**
	 * Get the user's list of teams they are on
	 *
	 * @param {*} id ownerID of the synapse user see - http://docs.synapse.org/rest/org/sagebionetworks/repo/model/UserProfile.html
	 */

	var getUserTeamList = function getUserTeamList(sessionToken, id) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  var url = "repo/v1/user/".concat(id, "/team?offset=0&limit=200");
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	/**
	 * Get the user's list of teams they are on
	 *
	 * @param {*} id ownerID of the synapse user see -https://docs.synapse.org/rest/GET/teamMembers/id.html
	 * @param {*} fragment (optional) a prefix of the user's first or last name or email address (optional)
	 * @param {*} limit    (optional) the maximum number of members to return (default 10, max limit 50)
	 * @param {*} offset   (optional) the starting index of the returned results (default 0)
	 *
	 */

	var getTeamList = function getTeamList(sessionToken, id) {
	  var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	  var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
	  var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	  var endpoint = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DEFAULT_ENDPOINT;
	  var url = "repo/v1/teamMembers/".concat(id, "?limit=").concat(limit, "&offset=").concat(offset).concat(fragment ? "&fragment=".concat(fragment) : '');
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	var getWikiAttachmentsFromEntity = function getWikiAttachmentsFromEntity(sessionToken, id, wikiId) {
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  var url = "repo/v1/entity/".concat(id, "/wiki/").concat(wikiId, "/attachmenthandles");
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	var getWikiAttachmentsFromEvaluation = function getWikiAttachmentsFromEvaluation(sessionToken, id, wikiId) {
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  var url = "repo/v1/evaluation/".concat(id, "/wiki/").concat(wikiId, "/attachmenthandles");
	  return doGet(url, sessionToken, undefined, endpoint);
	};
	/**
	 * Set the session token cookie.  Note that this will only succeed if your app is running on
	 * a .synapse.org subdomain.
	 *
	 * @param {*} token Session token.  If undefined, then call should instruct the browser to delete the cookie.
	 */

	var setSessionTokenCookie = function setSessionTokenCookie(token) {
	  if (!IS_DEV_ENV) {
	    return doPost('Portal/sessioncookie', {
	      sessionToken: token
	    }, undefined, 'include', DEFAULT_SWC_ENDPOINT);
	  } // else (is in dev env)


	  if (token) {
	    localStorage.setItem(DEV_ENV_SESSION_LOCAL_STORAGE_KEY, token);
	  } else {
	    localStorage.removeItem(DEV_ENV_SESSION_LOCAL_STORAGE_KEY);
	  }

	  return Promise.resolve();
	};
	/**
	 * Get the current session token from a cookie.  Note that this will only succeed if your app is running on
	 * a .synapse.org subdomain.
	 */

	var getSessionTokenFromCookie = function getSessionTokenFromCookie() {
	  if (!IS_DEV_ENV) {
	    return doGet('Portal/sessioncookie', undefined, 'include', DEFAULT_SWC_ENDPOINT);
	  } // else (is in dev env)


	  var sessionToken = localStorage.getItem(DEV_ENV_SESSION_LOCAL_STORAGE_KEY);
	  return Promise.resolve(sessionToken);
	};
	var getPrincipalAliasRequest = function getPrincipalAliasRequest(sessionToken, alias, type) {
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  var url = 'repo/v1/principal/alias';
	  return doPost(url, {
	    alias: alias,
	    type: type
	  }, sessionToken, undefined, endpoint);
	};
	/*
	During SSO login, the authorization provider (Google) will
	send the user back to the portal with an authorization code,
	which can be exchanged for a Synapse user session.
	This function should be called whenever the root App is initialized
	(to look for this code parameter and complete the round-trip).
	*/

	var detectSSOCode = function detectSSOCode() {
	  var redirectURL = getRootURL(); // 'code' handling (from SSO) should be preformed on the root page, and then redirect to original route.

	  var code = new URL(window.location.href); // in test environment the searchParams isn't defined

	  var _code = code,
	      searchParams = _code.searchParams;

	  if (!searchParams) {
	    return;
	  }

	  code = searchParams.get('code');

	  if (code) {
	    oAuthSessionRequest(AUTH_PROVIDER, code, "".concat(redirectURL, "?provider=").concat(AUTH_PROVIDER)).then(function (synToken) {
	      setSessionTokenCookie(synToken.sessionToken).then(function () {
	        // go back to original route after successful SSO login
	        var originalUrl = localStorage.getItem('after-sso-login-url');
	        localStorage.removeItem('after-sso-login-url');

	        if (originalUrl) {
	          window.location.replace(originalUrl);
	        }
	      }).catch(function (errSetSession) {
	        console.error('Error on set sesion token cookie ', errSetSession);
	      });
	    }).catch(function (err) {
	      if (err.statusCode === 404) {
	        // Synapse account not found, send to registration page
	        window.location.replace('https://www.synapse.org/#!RegisterAccount:0');
	      }

	      console.error('Error on sso sign in ', err);
	    });
	  }
	};
	var signOut = function signOut() {
	  setSessionTokenCookie(undefined).then(function () {
	    window.location.reload();
	  }).catch(function (err) {
	    console.error('err when clearing the session cookie ', err);
	  });
	};
	/**
	 * Upload file.  Note that this currently only supports Synapse storage (Sage s3 bucket)
	 * @param sessionToken
	 * @param file
	 * @param endpoint
	 */

	var uploadFile = function uploadFile(sessionToken, filename, file) {
	  var endpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ENDPOINT;
	  return new Promise(function (fileUploadResolve, fileUploadReject) {
	    var partSize = Math.max(5242880, file.size / 10000);
	    var request = {
	      contentType: file.type,
	      fileName: filename,
	      fileSizeBytes: file.size,
	      partSizeBytes: partSize,
	      storageLocationId: SYNAPSE_STORAGE_LOCATION_ID
	    };
	    calculateMd5(file).then(function (md5) {
	      request.contentMD5Hex = md5;
	      startMultipartUpload(sessionToken, filename, file, request, fileUploadResolve, fileUploadReject, endpoint);
	    });
	  });
	};

	var calculateMd5 = function calculateMd5(fileBlob) {
	  var bmf = new BMF();
	  return new Promise(function (resolve, reject) {
	    bmf.md5(fileBlob, function (error, md5) {
	      if (md5) {
	        resolve(md5);
	      } else if (error) {
	        reject(error);
	      }
	    }, function (progress) {// console.log('progress: ', progress)
	    });
	  });
	};

	var processFilePart = function processFilePart(partNumber, multipartUploadStatus, sessionToken, fileName, file, request, fileUploadResolve, fileUploadReject) {
	  var endpoint = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : DEFAULT_ENDPOINT;

	  if (multipartUploadStatus.clientSidePartsState[partNumber - 1]) {
	    // no-op. this part has already been processed!
	    return;
	  }

	  var uploadId = multipartUploadStatus.uploadId;
	  var presignedUploadUrlRequest = {
	    uploadId: uploadId,
	    contentType: 'application/octet-stream',
	    // each part is binary
	    partNumbers: [partNumber]
	  };
	  var presignedUrlUrl = "/file/v1/file/multipart/".concat(uploadId, "/presigned/url/batch");
	  doPost(presignedUrlUrl, presignedUploadUrlRequest, sessionToken, undefined, endpoint).then(
	  /*#__PURE__*/
	  function () {
	    var _ref4 = _asyncToGenerator(
	    /*#__PURE__*/
	    regeneratorRuntime.mark(function _callee4(presignedUrlResponse) {
	      var presignedUrl, startByte, endByte, fileSlice;
	      return regeneratorRuntime.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              presignedUrl = presignedUrlResponse.partPresignedUrls[0].uploadPresignedUrl; // calculate the byte range

	              startByte = (partNumber - 1) * request.partSizeBytes;
	              endByte = partNumber * request.partSizeBytes - 1;

	              if (endByte >= request.fileSizeBytes) {
	                endByte = request.fileSizeBytes - 1;
	              }

	              fileSlice = file.slice(startByte, endByte + 1, presignedUploadUrlRequest.contentType);
	              _context4.next = 7;
	              return uploadFilePart(presignedUrl, fileSlice, presignedUploadUrlRequest.contentType);

	            case 7:
	              // uploaded the part.  calculate md5 of the part and add the part to the upload
	              calculateMd5(fileSlice).then(function (md5) {
	                var addPartUrl = "/file/v1/file/multipart/".concat(uploadId, "/add/").concat(partNumber, "?partMD5Hex=").concat(md5);
	                doPut(addPartUrl, undefined, sessionToken, undefined, endpoint).then(function (addPartResponse) {
	                  if (addPartResponse.addPartState === 'ADD_SUCCESS') {
	                    // done with this part!
	                    multipartUploadStatus.clientSidePartsState[partNumber - 1] = true;
	                    checkUploadComplete(multipartUploadStatus, fileName, sessionToken, fileUploadResolve, fileUploadReject, endpoint);
	                  } else {
	                    // retry after a brief delay
	                    delay(1000).then(function () {
	                      processFilePart(partNumber, multipartUploadStatus, sessionToken, fileName, file, request, fileUploadResolve, fileUploadReject, endpoint);
	                    });
	                  }
	                });
	              });

	            case 8:
	            case "end":
	              return _context4.stop();
	          }
	        }
	      }, _callee4);
	    }));

	    return function (_x3) {
	      return _ref4.apply(this, arguments);
	    };
	  }());
	};

	var checkUploadComplete = function checkUploadComplete(status, fileHandleName, sessionToken, fileUploadResolve, fileUploadReject) {
	  var endpoint = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : DEFAULT_ENDPOINT;

	  // if all client-side parts are true (uploaded), then complete the upload and get the file handle!
	  if (status.clientSidePartsState.every(function (v) {
	    return v;
	  })) {
	    var url = "/file/v1/file/multipart/".concat(status.uploadId, "/complete");
	    doPut(url, undefined, sessionToken, undefined, endpoint).then(function (newStatus) {
	      // success!
	      fileUploadResolve({
	        fileHandleId: newStatus.resultFileHandleId,
	        fileName: fileHandleName
	      });
	    }).catch(function (error) {
	      fileUploadReject(error);
	    });
	  }
	};

	var uploadFilePart =
	/*#__PURE__*/
	function () {
	  var _ref5 = _asyncToGenerator(
	  /*#__PURE__*/
	  regeneratorRuntime.mark(function _callee5(presignedUrl, file, contentType) {
	    return regeneratorRuntime.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.next = 2;
	            return fetch(presignedUrl, {
	              method: 'PUT',
	              headers: {
	                'Content-Type': contentType
	              },
	              body: file
	            });

	          case 2:
	          case "end":
	            return _context5.stop();
	        }
	      }
	    }, _callee5);
	  }));

	  return function uploadFilePart(_x4, _x5, _x6) {
	    return _ref5.apply(this, arguments);
	  };
	}();

	var startMultipartUpload = function startMultipartUpload(sessionToken, fileName, file, request, fileUploadResolve, fileUploadReject) {
	  var endpoint = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : DEFAULT_ENDPOINT;
	  var url = 'file/v1/file/multipart';
	  doPost(url, request, sessionToken, undefined, endpoint).then(
	  /*#__PURE__*/
	  function () {
	    var _ref6 = _asyncToGenerator(
	    /*#__PURE__*/
	    regeneratorRuntime.mark(function _callee6(status) {
	      var clientSidePartsState, i;
	      return regeneratorRuntime.wrap(function _callee6$(_context6) {
	        while (1) {
	          switch (_context6.prev = _context6.next) {
	            case 0:
	              // started the upload
	              // keep track of the part state client-side
	              clientSidePartsState = status.partsState.split('').map(function (bit) {
	                return bit === '1';
	              });
	              status.clientSidePartsState = clientSidePartsState;
	              i = 0;

	            case 3:
	              if (!(i < clientSidePartsState.length)) {
	                _context6.next = 10;
	                break;
	              }

	              if (clientSidePartsState[i]) {
	                _context6.next = 7;
	                break;
	              }

	              _context6.next = 7;
	              return processFilePart(i + 1, status, sessionToken, fileName, file, request, fileUploadResolve, fileUploadReject, endpoint);

	            case 7:
	              i = i + 1;
	              _context6.next = 3;
	              break;

	            case 10:
	              // in case there is no upload work to do!
	              checkUploadComplete(status, fileName, sessionToken, fileUploadResolve, fileUploadReject, endpoint);

	            case 11:
	            case "end":
	              return _context6.stop();
	          }
	        }
	      }, _callee6);
	    }));

	    return function (_x7) {
	      return _ref6.apply(this, arguments);
	    };
	  }()).catch(function (error) {
	    fileUploadReject(error);
	  });
	};
	/**
	 * Return the content of the file (latest version) associated to the given FileEntity.
	 * Be aware that if the target file size > 5MB, this method will throw an error.
	 * @param sessionToken
	 * @param fileEntity
	 * @param endpoint
	 */

	var getFileEntityContent = function getFileEntityContent(sessionToken, fileEntity) {
	  var endpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ENDPOINT;
	  // get the presigned URL, download the data, and send that back (via resolve())
	  return new Promise(function (resolve, reject) {
	    var fileHandleAssociationList = [{
	      associateObjectId: fileEntity.id,
	      associateObjectType: 'FileEntity',
	      fileHandleId: fileEntity.dataFileHandleId
	    }];
	    var request = {
	      includeFileHandles: true,
	      includePreSignedURLs: true,
	      includePreviewPreSignedURLs: false,
	      requestedFiles: fileHandleAssociationList
	    };
	    getFiles(request, sessionToken, endpoint).then(function (data) {
	      var presignedUrl = data.requestedFiles[0].preSignedURL;
	      var fileHandle = data.requestedFiles[0].fileHandle; // sanity check!  must be less than 5MB

	      if (fileHandle.contentSize < MAX_JS_FILE_DOWNLOAD_SIZE) {
	        fetch(presignedUrl, {
	          method: 'GET',
	          mode: 'cors',
	          cache: 'no-cache',
	          headers: {
	            'Content-Type': fileHandle.contentType
	          }
	        }).then(function (response) {
	          response.text().then(function (text) {
	            resolve(text);
	          });
	        });
	      } else {
	        reject('File size exceeds max (5MB)');
	      }
	    }).catch(function (err) {
	      reject(err);
	    });
	  });
	};

	var SynapseClient = /*#__PURE__*/Object.freeze({
		IS_DEV_ENV: IS_DEV_ENV,
		DEV_ENV_SESSION_LOCAL_STORAGE_KEY: DEV_ENV_SESSION_LOCAL_STORAGE_KEY,
		AUTH_PROVIDER: AUTH_PROVIDER,
		SYNAPSE_STORAGE_LOCATION_ID: SYNAPSE_STORAGE_LOCATION_ID,
		getRootURL: getRootURL,
		doPost: doPost,
		doGet: doGet,
		doPut: doPut,
		putRefreshSessionToken: putRefreshSessionToken,
		getVersion: getVersion,
		getQueryTableResultsFromJobId: getQueryTableResultsFromJobId,
		getQueryTableResults: getQueryTableResults,
		getFullQueryTableResults: getFullQueryTableResults,
		login: login,
		oAuthUrlRequest: oAuthUrlRequest,
		oAuthSessionRequest: oAuthSessionRequest,
		createEntity: createEntity,
		createProject: createProject,
		getUserProfile: getUserProfile,
		getUserProfileById: getUserProfileById,
		getUserBundle: getUserBundle,
		getUserProfiles: getUserProfiles,
		getEntityChildren: getEntityChildren,
		lookupChildEntity: lookupChildEntity,
		getFiles: getFiles,
		getEntity: getEntity,
		updateEntity: updateEntity,
		getEntityBundleForVersion: getEntityBundleForVersion,
		getEntityWiki: getEntityWiki,
		getUserFavorites: getUserFavorites,
		getUserProjectList: getUserProjectList,
		getUserTeamList: getUserTeamList,
		getTeamList: getTeamList,
		getWikiAttachmentsFromEntity: getWikiAttachmentsFromEntity,
		getWikiAttachmentsFromEvaluation: getWikiAttachmentsFromEvaluation,
		setSessionTokenCookie: setSessionTokenCookie,
		getSessionTokenFromCookie: getSessionTokenFromCookie,
		getPrincipalAliasRequest: getPrincipalAliasRequest,
		detectSSOCode: detectSSOCode,
		signOut: signOut,
		uploadFile: uploadFile,
		checkUploadComplete: checkUploadComplete,
		startMultipartUpload: startMultipartUpload,
		getFileEntityContent: getFileEntityContent
	});

	// import { Facets } from './containers/Facets'
	var x = React.createElement("span", null);

	exports.SynapseClient = SynapseClient;
	exports.SynapseConstants = SynapseConstants;
	exports.x = x;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
